% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/funktionen_oo.R
\docType{data}
\name{node}
\alias{node}
\title{Store the session object of modules}
\value{
Public methods and fields are accesible using the '$' operator.
\item{add_child(child)}{Add a \code{child} node to private$children}
\item{child(path_to_child)}{Get a child of the node determined by the character
vector \code{path_to_child}. If there is a node in private$children with the name
of the first element of \code{path_to_child}, \code{child()} looks in the children
of this node for an child node with the name of the second element of
\code{path_to_child} and so on and returns the last child found. Calling this
method without arguments has the same effect as \code{children_names()}}
\item{children_names()}{Returns the names of all children nodes as a character
vector.}
\item{create_list()}{Returns a list representing all child and child-child nodes.}
\item{get(what)}{Returns the private field or method with the name \code{what}.}
\item{sibling(name)}{Returns the sibling node with name \code{name}. Calling this
method without arguments returns the names of all siblings.}

The following private fields and methods which are accesible via
\code{get()}:
\item{children}{A list of nodes.}
\item{name}{A character string, which is unique within \code{sibling()}.}
\item{parent}{A parent node.}
\item{session}{Usually a shiny session object.}
}
\description{
Use nodes to store the session objects of all modules in a shiny app in a tree-like
data-structure. A node object is an instantiation of the R6Class 'node'.
}
\details{
Instantiate a new node with \code{node$new(name, parent, session)}. Passing the
arguments \code{name} and \code{session} is mandatory. The root or entry node to
a tree obviously has no parent.
}
\examples{
\dontrun{
  # Entry point of shiny app
  server <- function(input, output, session) {
    # root node has no parent
    self <- node$new("root", session = session)

    shiny::callModule(module, "id_module", parent = self)
  }

  # Module server function
  module <- function(input, output, session, parent) {
    self <- node$new("module", parent, session)

    shiny::callModule(module, "id_module", parent = self)
  }

  module_2 <- function(input, output, session, parent) {
    # Children can have the same name as their parent
    self <- node$new("module", parent, session)
  }
}

# Instantiate nodes
root <- node$new("root", session = "session")
branch_1 <- node$new("branch_1", root, "session")
branch_2 <- node$new("branch_2", root, "session")
leave <- node$new("leave", branch_1, "session")

# Returns leave node
root$child(c("branch_1", "leave"))

# Returns branch_2 node
branch_1$sibling(branch_1$sibling()[[1]])
leave$get("parent")$sibling("branch_2")
leave$get("parent")$get("parent")$child("branch_2")

}
\keyword{datasets}
